{{define "status.gohtml"}}
{{template "layout" .}}
{{end}}

{{define "status.content"}}
<div class="page-header">
  <h2>Current status</h2>
</div>
{{if .Groups}}
  {{range .Groups}}
    <div class="card">
      <h3>{{if .Name}}{{.Name}}{{else}}Ungrouped{{end}}</h3>
      {{if .Monitors}}
      <table class="status-table" data-group="{{.Name}}">
        <thead>
          <tr>
            <th>Name</th>
            <th>Status</th>
            <th>Last check</th>
            <th>History</th>
            <th>Uptime</th>
          </tr>
        </thead>
        <tbody>
          {{range .Monitors}}
          <tr class="{{statusClass .Status}}" data-id="{{.ID}}">
            <td>
              <div>{{.Name}}</div>
              <div class="muted">{{.ID}}</div>
            </td>
            <td>
              {{if not .Enabled}}
                <span class="badge status-disabled">Disabled</span>
              {{else}}
                {{if .MasterDown}}
                  <span class="badge status-unknown" data-tip="Master monitor is down">Master down</span>
                {{else}}
                  <span class="badge {{statusClass .Status}}" data-field="status">{{.Status}}</span>
                {{end}}
              {{end}}
            </td>
            <td>
              <span class="muted" data-field="last-checked-rel">{{formatRelative .LastChecked}}</span>
            </td>
            <td>
              <div class="history" data-field="history">
                {{range .History}}
                  {{if .Success}}
                    <span class="up" data-tip="{{formatTime .Timestamp}} 路 OK"></span>
                  {{else}}
                    <span class="down" data-tip="{{formatTime .Timestamp}} 路 {{.Message}}"></span>
                  {{end}}
                {{end}}
              </div>
            </td>
            <td><span data-field="uptime">{{printf "%.1f" .SuccessRate}}%</span></td>
          </tr>
          {{end}}
        </tbody>
      </table>
      {{else}}
        <p class="muted">No monitors in this group.</p>
      {{end}}
    </div>
  {{end}}
{{else}}
  <p class="muted">No monitors configured yet. Visit the admin area to create one.</p>
{{end}}
<style>
  /* Lightweight tooltip styling scoped to status page */
  #upturtle-tooltip {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    background: rgba(24,24,24,0.95);
    color: #e2e8f0;
    border: 1px solid rgba(160,160,160,0.25);
    padding: .35rem .5rem;
    border-radius: 6px;
    font-size: .8rem;
    box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    max-width: 420px;
    white-space: pre-line; /* preserve \n from data-tip while wrapping */
    line-height: 1.25;
    overflow: visible;
    display: none;
  }
  /* Break long continuous strings to avoid overflow */
  #upturtle-tooltip { word-break: break-word; }

  /* Refresh control dark styling */
  #refresh-control {
    background: rgba(24,24,24,0.85);
    border: 1px solid rgba(160,160,160,0.2);
    color: #d1d5db;
    box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  }
  #refresh-select {
    background-color: rgba(40,40,40,0.6);
    color: #e2e8f0;
    border: 1px solid rgba(160,160,160,0.3);
    border-radius: 6px;
    padding: .32rem 2rem .32rem .6rem;
    outline: none;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23e2e8f0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right .5rem center;
    background-size: 16px 16px;
  }
  #refresh-select:hover { border-color: rgba(160,160,160,0.45); }
  #refresh-select:focus { border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99,102,241,.25); }
  #refresh-select option {
    background: #1f1f23;
    color: #e2e8f0;
  }
</style>
<script>
(function(){
  // Simple tooltip for elements with [data-tip]
  let tipEl;
  function ensureTip(){
    if(!tipEl){
      tipEl = document.createElement('div');
      tipEl.id = 'upturtle-tooltip';
      document.body.appendChild(tipEl);
    }
    return tipEl;
  }
  function showTip(text, x, y){
    const el = ensureTip();
    el.textContent = String(text || '');
    el.style.display = 'block';
    // Position with viewport bounds checking
    const margin = 10;
    const rect = { w: el.offsetWidth, h: el.offsetHeight };
    let left = x + 12;
    let top = y + 12;
    if(left + rect.w + margin > window.innerWidth){ left = x - rect.w - 12; }
    if(top + rect.h + margin > window.innerHeight){ top = y - rect.h - 12; }
    el.style.left = Math.max(margin, left) + 'px';
    el.style.top = Math.max(margin, top) + 'px';
  }
  function hideTip(){ if(tipEl){ tipEl.style.display = 'none'; } }
  let currentTarget = null;
  document.addEventListener('mouseover', function(ev){
    const t = ev.target.closest('[data-tip]');
    if(t){ currentTarget = t; showTip(t.getAttribute('data-tip'), ev.clientX, ev.clientY); }
  });
  document.addEventListener('mousemove', function(ev){ if(currentTarget){ showTip(currentTarget.getAttribute('data-tip'), ev.clientX, ev.clientY); } });
  document.addEventListener('mouseout', function(ev){
    if(currentTarget && !ev.relatedTarget){ currentTarget = null; hideTip(); return; }
    if(currentTarget && !ev.relatedTarget?.closest('[data-tip]')){ currentTarget = null; hideTip(); }
  });
})();
</script>
<div id="refresh-control" style="position:fixed; left:12px; bottom:12px; background: rgba(24,24,24,0.85); border:1px solid rgba(160,160,160,0.2); padding:.5rem .75rem; border-radius: 8px; font-size:.9rem; color:#d1d5db;">
  <label for="refresh-select" style="margin-right:.5rem;">Refresh:</label>
  <select id="refresh-select">
    <option value="5000">5s</option>
    <option value="10000" selected>10s</option>
    <option value="15000">15s</option>
    <option value="30000">30s</option>
    <option value="60000">60s</option>
  </select>
  <span class="muted" style="margin-left:.5rem;">auto refresh</span>
  </div>
<script>
(function(){
  const KEY = 'upturtle_status_poll_ms';
  function getPollMs(){
    const v = localStorage.getItem(KEY);
    const n = parseInt(v||'10000', 10);
    if (!isFinite(n) || n < 1000) return 10000;
    return n;
  }
  function setPollMs(n){ localStorage.setItem(KEY, String(n)); }
  function initControl(){
    const sel = document.getElementById('refresh-select');
    if(!sel) return;
    const current = getPollMs();
    for(const o of sel.options){ if(parseInt(o.value,10)===current){ o.selected = true; break; } }
    sel.addEventListener('change', function(){
      const n = parseInt(sel.value,10); setPollMs(n);
    });
  }
  function statusClass(s){
    if(s === 'up') return 'status-up';
    if(s === 'down') return 'status-down';
    return 'status-unknown';
  }
  const HISTORY_PREVIEW = 20;
  function formatDuration(ms){
    if(ms <= 0) return '-';
    if(ms < 1000) return Math.round(ms) + 'ms';
    return (ms/1000).toFixed(3) + 's';
  }
  function formatAbs(ts){
    if(!ts) return '-';
    const d = new Date(ts);
    if(isNaN(d.getTime())) return '-';
    return d.toLocaleString();
  }
  function formatRel(ts){
    if(!ts) return '';
    const d = new Date(ts);
    if(isNaN(d.getTime())) return '';
    const diff = Date.now() - d.getTime();
    // If more than 365 days ago, treat as no data
    if(diff > 365 * 24 * 60 * 60 * 1000) return '';
    const s = Math.max(1, Math.floor(diff/1000));
    if(s < 60) return s + 's ago';
    const m = Math.floor(s/60); if(m < 60) return m + 'm ago';
    const h = Math.floor(m/60); if(h < 24) return h + 'h ago';
    const ddays = Math.floor(h/24); return ddays + 'd ago';
  }
  let timer = null; let running = false;

  function renderHistoryHTML(arr){
    const items = Array.isArray(arr) ? arr : [];
    const real = items.map(h => {
      const tipText = formatAbs(h.timestamp) + ' 路 ' + (h.success ? 'OK' : (h.message || ''));
      const encodedTip = btoa(encodeURIComponent(tipText));
      const className = h.success ? 'up' : 'down';
      // include data-ts for incremental updates
      return `<span class="${className}" data-ts="${String(h.timestamp)}" data-tip-encoded="${encodedTip}" onmouseover="this.setAttribute('data-tip', decodeURIComponent(atob(this.getAttribute('data-tip-encoded'))))"></span>`;
    });
    const placeholders = [];
    const need = Math.max(0, HISTORY_PREVIEW - real.length);
    for (let i = 0; i < need; i++) {
      placeholders.push('<span class="unknown" data-tip="unknown"></span>');
    }
    // unknown placeholders should be on the LEFT of the real values
    return placeholders.join('') + real.join('');
  }

  function padExistingHistories(){
    document.querySelectorAll('.history').forEach(el => {
      const current = el.children.length;
      const need = Math.max(0, HISTORY_PREVIEW - current);
      for(let i=0; i < need; i++){
        const sp = document.createElement('span');
        sp.className = 'unknown';
        sp.setAttribute('data-tip', 'unknown');
        el.insertBefore(sp, el.firstChild);
      }
    });
  }
  // Create a history span DOM node from a history item
  function createHistorySpan(h){
    const tipText = formatAbs(h.timestamp) + ' 路 ' + (h.success ? 'OK' : (h.message || ''));
    const encodedTip = btoa(encodeURIComponent(tipText));
    const sp = document.createElement('span');
    sp.className = h.success ? 'up' : 'down';
    sp.setAttribute('data-ts', String(h.timestamp));
    sp.setAttribute('data-tip-encoded', encodedTip);
    sp.onmouseover = function(){
      this.setAttribute('data-tip', decodeURIComponent(atob(this.getAttribute('data-tip-encoded'))));
    };
    return sp;
  }
  // Incrementally update history: append new items (by timestamp) and remove oldest to keep length
  function updateHistoryIncremental(histEl, incoming){
    if(!histEl) return;
    const items = Array.isArray(incoming) ? incoming : [];
    if(items.length === 0) return;

    // Determine last known timestamp on the RIGHT-most real item
    let lastKnownTs = null;
    for(let i = histEl.children.length - 1; i >= 0; i--){
      const ch = histEl.children[i];
      const ts = ch.getAttribute && ch.getAttribute('data-ts');
      if(ts){ lastKnownTs = ts; break; }
    }

    // If no timestamps in DOM (first-time or server-rendered), full render
    if(!lastKnownTs){
      histEl.innerHTML = renderHistoryHTML(items);
      return;
    }

    // Collect new items strictly newer than lastKnownTs, in correct order
    const toAppend = [];
    for(let i = 0; i < items.length; i++){
      const it = items[i];
      if(String(it.timestamp) > String(lastKnownTs)){
        toAppend.push(it);
      }
    }
    if(toAppend.length === 0){
      return; // nothing new
    }

    // Append new ones to the right
    toAppend.forEach(h => {
      histEl.appendChild(createHistorySpan(h));
    });

    // Ensure length: remove from left first real or unknowns to maintain HISTORY_PREVIEW
    // Compute excess
    let total = histEl.children.length;
    const maxLen = HISTORY_PREVIEW;
    while(total > maxLen){
      if(histEl.firstChild){ histEl.removeChild(histEl.firstChild); total--; } else { break; }
    }
  }
  async function poll(){
    try {
      const res = await fetch('/api/status', { cache: 'no-store', redirect: 'follow', credentials: 'same-origin' });
      // If session expired, the server redirects to /login; detect and navigate
      if (res.redirected || (res.url && res.url.indexOf('/login') !== -1)) {
        window.location.href = '/login';
        return;
      }
      if (res.status === 401 || res.status === 403) {
        window.location.href = '/login';
        return;
      }
      const ct = res.headers.get('content-type') || '';
      if (ct.indexOf('application/json') === -1) {
        // Likely got HTML (e.g., login page). Redirect to login.
        window.location.href = '/login';
        return;
      }
      if(!res.ok) throw new Error('http '+res.status);
      const data = await res.json();
      const byId = {};
      data.forEach(x => { byId[x.id] = x; });
      document.querySelectorAll('table.status-table tbody tr[data-id]').forEach(tr => {
        const id = tr.getAttribute('data-id');
        const it = byId[id];
        if(!it) return;

        // Always update row class (cheap) and master-dependent status badge
        tr.classList.remove('status-up','status-down','status-unknown');
        tr.classList.add(statusClass(it.status));
        const statusCell = tr.querySelector('[data-field="status"]');
        const statusContainer = tr.querySelector('td:nth-child(2)');
        const isMasterDown = !!(it.master_id && byId[it.master_id] && byId[it.master_id].status === 'down');
        if(isMasterDown){
          if(statusContainer){ statusContainer.innerHTML = '<span class="badge status-unknown" data-tip="Master monitor is down">Master down<\/span>'; }
        } else if(statusCell){
          statusCell.className = 'badge ' + statusClass(it.status);
          statusCell.textContent = it.status;
        }

        // Always refresh relative time text
        const relEl = tr.querySelector('[data-field="last-checked-rel"]');
        if(relEl) relEl.textContent = formatRel(it.last_checked);

        // History and uptime: initialize once, then incremental updates only when new data
        const histEl = tr.querySelector('[data-field="history"]');
        const upEl = tr.querySelector('[data-field="uptime"]');
        const initialized = tr.getAttribute('data-init') === '1';
        if(!initialized){
          if(histEl && Array.isArray(it.history)){
            histEl.innerHTML = renderHistoryHTML(it.history);
          }
          if(upEl && Array.isArray(it.history) && it.history.length){
            const ok = it.history.filter(h => h.success).length;
            upEl.textContent = ((ok / it.history.length) * 100).toFixed(1) + '%';
          }
          tr.setAttribute('data-last-checked', String(it.last_checked || ''));
          tr.setAttribute('data-init', '1');
        } else {
          const prevLC = tr.getAttribute('data-last-checked') || '';
          const currLC = String(it.last_checked || '');
          if(prevLC !== currLC){
            // Incremental history update
            if(histEl && Array.isArray(it.history)){
              updateHistoryIncremental(histEl, it.history);
            }
            // Recompute uptime from current 20-window
            if(upEl){
              const children = histEl ? Array.from(histEl.children) : [];
              if(children.length){
                const total = Math.min(children.length, HISTORY_PREVIEW);
                let okCount = 0;
                for(const ch of children){ if(ch.classList.contains('up')) okCount++; }
                upEl.textContent = ((okCount / total) * 100).toFixed(1) + '%';
              }
            }
            tr.setAttribute('data-last-checked', currLC);
          }
        }
      });
    } catch(e) { /* ignore transient errors */ }
    finally {
      const next = getPollMs();
      timer = setTimeout(poll, next);
    }
  }
  initControl();
  padExistingHistories();
  poll();
  // React to user changes immediately
  const sel = document.getElementById('refresh-select');
  if(sel){ sel.addEventListener('change', function(){ if(timer){ clearTimeout(timer); } poll(); }); }
})();
</script>
{{end}}
