{{define "status.gohtml"}}
{{template "layout" .}}
{{end}}

{{define "status.content"}}
<div class="page-header">
  <h2>Current status</h2>
</div>
{{if .Groups}}
  {{range .Groups}}
    <div class="card">
      <h3>{{if .Name}}{{.Name}}{{else}}Ungrouped{{end}}</h3>
      {{if .Monitors}}
      <table class="status-table" data-group="{{.Name}}">
        <thead>
          <tr>
            <th>Name</th>
            <th>Status</th>
            <th>Last check</th>
            <th>History</th>
            <th>Uptime</th>
          </tr>
        </thead>
        <tbody>
          {{range .Monitors}}
          <tr class="monitor-row {{statusClass .Status}}" data-id="{{.ID}}" data-type="{{.Type}}">
            <td>
              <div>{{.Name}}</div>
              <div class="muted">{{.ID}}</div>
            </td>
            <td>
              {{if not .Enabled}}
                <span class="badge status-disabled">Disabled</span>
              {{else}}
                {{if .MasterDown}}
                  <span class="badge status-unknown" data-tip="Master monitor is down">Master down</span>
                {{else}}
                  <span class="badge {{statusClass .Status}}" data-field="status">{{.Status}}</span>
                {{end}}
              {{end}}
            </td>
            <td>
              <span class="muted" data-field="last-checked-rel">{{formatRelative .LastChecked}}</span>
            </td>
            <td>
              <div class="history" data-field="history">
                {{range .History}}
                  {{if .Success}}
                    <span class="up" data-tip="{{formatTime .Timestamp}} 路 OK"></span>
                  {{else}}
                    <span class="down" data-tip="{{formatTime .Timestamp}} 路 {{.Message}}"></span>
                  {{end}}
                {{end}}
              </div>
            </td>
            <td><span data-field="uptime">{{printf "%.1f" .SuccessRate}}%</span></td>
          </tr>
          <tr class="chart-row" data-monitor-id="{{.ID}}" style="display: none;">
            <td colspan="5" style="padding: 0;">
              <div class="chart-container" style="overflow: hidden; height: 0; transition: height 0.3s ease;">
                <div class="chart-content" style="padding: 1.5rem;">
                  <div class="chart-loading">Loading chart data...</div>
                  <canvas class="monitor-chart" style="display: none; height: 375px;"></canvas>
                </div>
              </div>
            </td>
          </tr>
          {{end}}
        </tbody>
      </table>
      {{else}}
        <p class="muted">No monitors in this group.</p>
      {{end}}
    </div>
  {{end}}
{{else}}
  <p class="muted">No monitors configured yet. Visit the admin area to create one.</p>
{{end}}
<style>
  /* Lightweight tooltip styling scoped to status page */
  #upturtle-tooltip {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    background: rgba(24,24,24,0.95);
    color: #e2e8f0;
    border: 1px solid rgba(160,160,160,0.25);
    padding: .35rem .5rem;
    border-radius: 6px;
    font-size: .8rem;
    box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    max-width: 420px;
    white-space: pre-line; /* preserve \n from data-tip while wrapping */
    line-height: 1.25;
    overflow: visible;
    display: none;
  }
  /* Break long continuous strings to avoid overflow */
  #upturtle-tooltip { word-break: break-word; }

  /* Refresh control dark styling */
  #refresh-control {
    background: rgba(24,24,24,0.85);
    border: 1px solid rgba(160,160,160,0.2);
    color: #d1d5db;
    box-shadow: 0 6px 18px rgba(0,0,0,0.25);
  }
  #refresh-select {
    background-color: rgba(40,40,40,0.6);
    color: #e2e8f0;
    border: 1px solid rgba(160,160,160,0.3);
    border-radius: 6px;
    padding: .32rem 2rem .32rem .6rem;
    outline: none;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23e2e8f0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right .5rem center;
    background-size: 16px 16px;
  }
  #refresh-select:hover { border-color: rgba(160,160,160,0.45); }
  #refresh-select:focus { border-color: #6366f1; box-shadow: 0 0 0 3px rgba(99,102,241,.25); }
  #refresh-select option {
    background: #1f1f23;
    color: #e2e8f0;
  }

  /* Chart row styles */
  tr.monitor-row { cursor: pointer; transition: background-color 0.2s ease; }
  tr.monitor-row:hover { background-color: rgba(160, 160, 160, 0.08); }
  tr.chart-row { border-bottom: none; }
  .chart-container { background: rgba(30, 30, 30, 0.5); }
  .chart-loading { text-align: center; color: #a1a1aa; padding: 2rem; }
</style>
<script>
(function(){
  // Simple tooltip for elements with [data-tip]
  let tipEl;
  function ensureTip(){
    if(!tipEl){
      tipEl = document.createElement('div');
      tipEl.id = 'upturtle-tooltip';
      document.body.appendChild(tipEl);
    }
    return tipEl;
  }
  function showTip(text, x, y){
    const el = ensureTip();
    el.textContent = String(text || '');
    el.style.display = 'block';
    // Position with viewport bounds checking
    const margin = 10;
    const rect = { w: el.offsetWidth, h: el.offsetHeight };
    let left = x + 12;
    let top = y + 12;
    if(left + rect.w + margin > window.innerWidth){ left = x - rect.w - 12; }
    if(top + rect.h + margin > window.innerHeight){ top = y - rect.h - 12; }
    el.style.left = Math.max(margin, left) + 'px';
    el.style.top = Math.max(margin, top) + 'px';
  }
  function hideTip(){ if(tipEl){ tipEl.style.display = 'none'; } }
  let currentTarget = null;
  document.addEventListener('mouseover', function(ev){
    const t = ev.target.closest('[data-tip]');
    if(t){ currentTarget = t; showTip(t.getAttribute('data-tip'), ev.clientX, ev.clientY); }
  });
  document.addEventListener('mousemove', function(ev){ if(currentTarget){ showTip(currentTarget.getAttribute('data-tip'), ev.clientX, ev.clientY); } });
  document.addEventListener('mouseout', function(ev){
    if(currentTarget && !ev.relatedTarget){ currentTarget = null; hideTip(); return; }
    if(currentTarget && !ev.relatedTarget?.closest('[data-tip]')){ currentTarget = null; hideTip(); }
  });
})();
</script>
<div id="refresh-control" style="position:fixed; left:12px; bottom:12px; background: rgba(24,24,24,0.85); border:1px solid rgba(160,160,160,0.2); padding:.5rem .75rem; border-radius: 8px; font-size:.9rem; color:#d1d5db;">
  <label for="refresh-select" style="margin-right:.5rem;">Refresh:</label>
  <select id="refresh-select">
    <option value="5000">5s</option>
    <option value="10000" selected>10s</option>
    <option value="15000">15s</option>
    <option value="30000">30s</option>
    <option value="60000">60s</option>
  </select>
  <span class="muted" style="margin-left:.5rem;">auto refresh</span>
  </div>
<script>
(function(){
  const KEY = 'upturtle_status_poll_ms';
  function getPollMs(){
    const v = localStorage.getItem(KEY);
    const n = parseInt(v||'10000', 10);
    if (!isFinite(n) || n < 1000) return 10000;
    return n;
  }
  function setPollMs(n){ localStorage.setItem(KEY, String(n)); }
  function initControl(){
    const sel = document.getElementById('refresh-select');
    if(!sel) return;
    const current = getPollMs();
    for(const o of sel.options){ if(parseInt(o.value,10)===current){ o.selected = true; break; } }
    sel.addEventListener('change', function(){
      const n = parseInt(sel.value,10); setPollMs(n);
    });
  }
  function statusClass(s){
    if(s === 'up') return 'status-up';
    if(s === 'down') return 'status-down';
    return 'status-unknown';
  }
  const HISTORY_PREVIEW = 20;
  function formatDuration(ms){
    if(ms <= 0) return '-';
    if(ms < 1000) return Math.round(ms) + 'ms';
    return (ms/1000).toFixed(3) + 's';
  }
  function formatAbs(ts){
    if(!ts) return '-';
    const d = new Date(ts);
    if(isNaN(d.getTime())) return '-';
    return d.toLocaleString();
  }
  function formatRel(ts){
    if(!ts) return '';
    const d = new Date(ts);
    if(isNaN(d.getTime())) return '';
    const diff = Date.now() - d.getTime();
    // If more than 365 days ago, treat as no data
    if(diff > 365 * 24 * 60 * 60 * 1000) return '';
    const s = Math.max(1, Math.floor(diff/1000));
    if(s < 60) return s + 's ago';
    const m = Math.floor(s/60); if(m < 60) return m + 'm ago';
    const h = Math.floor(m/60); if(h < 24) return h + 'h ago';
    const ddays = Math.floor(h/24); return ddays + 'd ago';
  }
  let timer = null; let running = false;

  function renderHistoryHTML(arr){
    const items = Array.isArray(arr) ? arr : [];
    const real = items.map(h => {
      const tipText = formatAbs(h.timestamp) + ' 路 ' + (h.success ? 'OK' : (h.message || ''));
      const encodedTip = btoa(encodeURIComponent(tipText));
      const className = h.success ? 'up' : 'down';
      // include data-ts for incremental updates
      return `<span class="${className}" data-ts="${String(h.timestamp)}" data-tip-encoded="${encodedTip}" onmouseover="this.setAttribute('data-tip', decodeURIComponent(atob(this.getAttribute('data-tip-encoded'))))"></span>`;
    });
    const placeholders = [];
    const need = Math.max(0, HISTORY_PREVIEW - real.length);
    for (let i = 0; i < need; i++) {
      placeholders.push('<span class="unknown" data-tip="unknown"></span>');
    }
    // unknown placeholders should be on the LEFT of the real values
    return placeholders.join('') + real.join('');
  }

  function padExistingHistories(){
    document.querySelectorAll('.history').forEach(el => {
      const current = el.children.length;
      const need = Math.max(0, HISTORY_PREVIEW - current);
      for(let i=0; i < need; i++){
        const sp = document.createElement('span');
        sp.className = 'unknown';
        sp.setAttribute('data-tip', 'unknown');
        el.insertBefore(sp, el.firstChild);
      }
    });
  }
  // Create a history span DOM node from a history item
  function createHistorySpan(h){
    const tipText = formatAbs(h.timestamp) + ' 路 ' + (h.success ? 'OK' : (h.message || ''));
    const encodedTip = btoa(encodeURIComponent(tipText));
    const sp = document.createElement('span');
    sp.className = h.success ? 'up' : 'down';
    sp.setAttribute('data-ts', String(h.timestamp));
    sp.setAttribute('data-tip-encoded', encodedTip);
    sp.onmouseover = function(){
      this.setAttribute('data-tip', decodeURIComponent(atob(this.getAttribute('data-tip-encoded'))));
    };
    return sp;
  }
  // Incrementally update history: append new items (by timestamp) and remove oldest to keep length
  function updateHistoryIncremental(histEl, incoming){
    if(!histEl) return;
    const items = Array.isArray(incoming) ? incoming : [];
    if(items.length === 0) return;

    // Determine last known timestamp on the RIGHT-most real item
    let lastKnownTs = null;
    for(let i = histEl.children.length - 1; i >= 0; i--){
      const ch = histEl.children[i];
      const ts = ch.getAttribute && ch.getAttribute('data-ts');
      if(ts){ lastKnownTs = ts; break; }
    }

    // If no timestamps in DOM (first-time or server-rendered), full render
    if(!lastKnownTs){
      histEl.innerHTML = renderHistoryHTML(items);
      return;
    }

    // Collect new items strictly newer than lastKnownTs, in correct order
    const toAppend = [];
    for(let i = 0; i < items.length; i++){
      const it = items[i];
      if(String(it.timestamp) > String(lastKnownTs)){
        toAppend.push(it);
      }
    }
    if(toAppend.length === 0){
      return; // nothing new
    }

    // Append new ones to the right
    toAppend.forEach(h => {
      histEl.appendChild(createHistorySpan(h));
    });

    // Ensure length: remove from left first real or unknowns to maintain HISTORY_PREVIEW
    // Compute excess
    let total = histEl.children.length;
    const maxLen = HISTORY_PREVIEW;
    while(total > maxLen){
      if(histEl.firstChild){ histEl.removeChild(histEl.firstChild); total--; } else { break; }
    }
  }
  async function poll(){
    try {
      const res = await fetch('/api/status', { cache: 'no-store', redirect: 'follow', credentials: 'same-origin' });
      // If session expired, the server redirects to /login; detect and navigate
      if (res.redirected || (res.url && res.url.indexOf('/login') !== -1)) {
        window.location.href = '/login';
        return;
      }
      if (res.status === 401 || res.status === 403) {
        window.location.href = '/login';
        return;
      }
      const ct = res.headers.get('content-type') || '';
      if (ct.indexOf('application/json') === -1) {
        // Likely got HTML (e.g., login page). Redirect to login.
        window.location.href = '/login';
        return;
      }
      if(!res.ok) throw new Error('http '+res.status);
      const data = await res.json();
      const byId = {};
      data.forEach(x => { byId[x.id] = x; });
      document.querySelectorAll('table.status-table tbody tr[data-id]').forEach(tr => {
        const id = tr.getAttribute('data-id');
        const it = byId[id];
        if(!it) return;

        // Always update row class (cheap) and master-dependent status badge
        tr.classList.remove('status-up','status-down','status-unknown');
        tr.classList.add(statusClass(it.status));
        const statusCell = tr.querySelector('[data-field="status"]');
        const statusContainer = tr.querySelector('td:nth-child(2)');
        const isMasterDown = !!(it.master_id && byId[it.master_id] && byId[it.master_id].status === 'down');
        if(isMasterDown){
          if(statusContainer){ statusContainer.innerHTML = '<span class="badge status-unknown" data-tip="Master monitor is down">Master down<\/span>'; }
        } else if(statusCell){
          statusCell.className = 'badge ' + statusClass(it.status);
          statusCell.textContent = it.status;
        }

        // Always refresh relative time text
        const relEl = tr.querySelector('[data-field="last-checked-rel"]');
        if(relEl) relEl.textContent = formatRel(it.last_checked);

        // History and uptime: initialize once, then incremental updates only when new data
        const histEl = tr.querySelector('[data-field="history"]');
        const upEl = tr.querySelector('[data-field="uptime"]');
        const initialized = tr.getAttribute('data-init') === '1';
        if(!initialized){
          if(histEl && Array.isArray(it.history)){
            histEl.innerHTML = renderHistoryHTML(it.history);
          }
          if(upEl && Array.isArray(it.history) && it.history.length){
            const ok = it.history.filter(h => h.success).length;
            upEl.textContent = ((ok / it.history.length) * 100).toFixed(1) + '%';
          }
          tr.setAttribute('data-last-checked', String(it.last_checked || ''));
          tr.setAttribute('data-init', '1');
        } else {
          const prevLC = tr.getAttribute('data-last-checked') || '';
          const currLC = String(it.last_checked || '');
          if(prevLC !== currLC){
            // Incremental history update
            if(histEl && Array.isArray(it.history)){
              updateHistoryIncremental(histEl, it.history);
            }
            // Recompute uptime from current 20-window
            if(upEl){
              const children = histEl ? Array.from(histEl.children) : [];
              if(children.length){
                const total = Math.min(children.length, HISTORY_PREVIEW);
                let okCount = 0;
                for(const ch of children){ if(ch.classList.contains('up')) okCount++; }
                upEl.textContent = ((okCount / total) * 100).toFixed(1) + '%';
              }
            }
            tr.setAttribute('data-last-checked', currLC);
          }
        }
      });
    } catch(e) { /* ignore transient errors */ }
    finally {
      const next = getPollMs();
      timer = setTimeout(poll, next);
    }
  }
  initControl();
  padExistingHistories();
  poll();
  // React to user changes immediately
  const sel = document.getElementById('refresh-select');
  if(sel){ sel.addEventListener('change', function(){ if(timer){ clearTimeout(timer); } poll(); }); }
})();

// Chart expansion functionality
(function(){
  let currentOpenMonitorId = null;
  let chartInstances = {}; // Store chart instances to destroy them later
  let animationTimeouts = {}; // Store animation timeouts to cancel them
  let isAnimating = {}; // Track which monitors are currently animating

  // Handle monitor row clicks
  document.addEventListener('click', function(ev){
    const monitorRow = ev.target.closest('tr.monitor-row');
    if(!monitorRow) return;

    const monitorId = monitorRow.getAttribute('data-id');
    const monitorType = monitorRow.getAttribute('data-type');
    
    // Prevent multiple clicks during animation
    if(isAnimating[monitorId]) return;
    
    // If clicking the same row, close it
    if(currentOpenMonitorId === monitorId){
      closeChart(monitorId);
      currentOpenMonitorId = null;
      return;
    }

    // If another chart is open, close it first
    if(currentOpenMonitorId){
      closeChart(currentOpenMonitorId);
    }

    // Open the new chart
    openChart(monitorId, monitorType);
    currentOpenMonitorId = monitorId;
  });

  function openChart(monitorId, monitorType){
    const chartRow = document.querySelector(`tr.chart-row[data-monitor-id="${monitorId}"]`);
    if(!chartRow) return;

    const container = chartRow.querySelector('.chart-container');
    const loading = chartRow.querySelector('.chart-loading');
    const canvas = chartRow.querySelector('.monitor-chart');

    // Cancel any pending animation timeout for this monitor
    if(animationTimeouts[monitorId]){
      clearTimeout(animationTimeouts[monitorId]);
      delete animationTimeouts[monitorId];
    }

    // Mark as animating
    isAnimating[monitorId] = true;

    // Force reflow to ensure transition works
    container.style.transition = 'none';
    container.style.height = '0';
    chartRow.style.display = '';
    
    // Force reflow
    void container.offsetHeight;
    
    // Re-enable transition and animate
    container.style.transition = 'height 0.3s ease';
    container.style.height = '400px';

    // Show loading state
    loading.style.display = 'block';
    canvas.style.display = 'none';

    // Mark animation as complete after transition
    animationTimeouts[monitorId] = setTimeout(function(){
      isAnimating[monitorId] = false;
      delete animationTimeouts[monitorId];
    }, 300);

    // Fetch chart data
    fetch(`/api/monitors/chart/${monitorId}`)
      .then(res => {
        if(!res.ok) throw new Error('Failed to fetch chart data');
        return res.json();
      })
      .then(data => {
        loading.style.display = 'none';
        canvas.style.display = 'block';
        renderChart(canvas, data, monitorType);
      })
      .catch(err => {
        console.error('Error loading chart:', err);
        loading.textContent = 'Error loading chart data';
      });
  }

  function closeChart(monitorId){
    const chartRow = document.querySelector(`tr.chart-row[data-monitor-id="${monitorId}"]`);
    if(!chartRow) return;

    const container = chartRow.querySelector('.chart-container');
    const loading = chartRow.querySelector('.chart-loading');
    const canvas = chartRow.querySelector('.monitor-chart');

    // Cancel any pending animation timeout for this monitor
    if(animationTimeouts[monitorId]){
      clearTimeout(animationTimeouts[monitorId]);
      delete animationTimeouts[monitorId];
    }

    // Mark as animating
    isAnimating[monitorId] = true;

    // Destroy chart instance if exists
    if(chartInstances[monitorId]){
      chartInstances[monitorId].destroy();
      delete chartInstances[monitorId];
    }

    // Animate height to 0
    container.style.transition = 'height 0.3s ease';
    container.style.height = '0';

    // After animation, hide row and reset content
    animationTimeouts[monitorId] = setTimeout(function(){
      chartRow.style.display = 'none';
      loading.style.display = 'block';
      loading.textContent = 'Loading chart data...';
      canvas.style.display = 'none';
      isAnimating[monitorId] = false;
      delete animationTimeouts[monitorId];
    }, 300);
  }

  function renderChart(canvas, data, monitorType){
    const ctx = canvas.getContext('2d');
    
    // Destroy existing chart if any
    if(chartInstances[data.id]){
      chartInstances[data.id].destroy();
    }

    // Format timestamps for display - show date only once per day
    const labels = data.timestamps.map((ts, i) => {
      const d = new Date(ts);
      const prevD = i > 0 ? new Date(data.timestamps[i - 1]) : null;
      
      // Check if this is a new day
      const isNewDay = !prevD || 
                       d.getDate() !== prevD.getDate() || 
                       d.getMonth() !== prevD.getMonth() || 
                       d.getFullYear() !== prevD.getFullYear();
      
      if(isNewDay){
        // Show full date and time for first entry of the day
        return d.toLocaleString('de-DE', { 
          day: '2-digit',
          month: '2-digit',
          hour: '2-digit', 
          minute: '2-digit' 
        });
      } else {
        // Show only time for subsequent entries
        return d.toLocaleTimeString('de-DE', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
      }
    });

    // Create datasets based on monitor type
    const datasets = [];

    // For all monitor types, show latency (only when status is up)
    datasets.push({
      label: 'Response Time (ms)',
      data: data.latencies.map((lat, i) => data.statuses[i] === 1 ? lat : null),
      borderColor: '#3b82f6',
      backgroundColor: 'rgba(59, 130, 246, 0.1)',
      borderWidth: 2,
      fill: true,
      tension: 0.4,
      pointRadius: 0,
      pointHoverRadius: 0,
      spanGaps: false,
      yAxisID: 'y'
    });

    // Add status as a separate dataset on secondary y-axis
    datasets.push({
      label: 'Status',
      data: data.statuses,
      borderColor: '#34d399',
      backgroundColor: 'rgba(52, 211, 153, 0.1)',
      borderWidth: 2,
      fill: false,
      stepped: true,
      pointRadius: 0,
      pointHoverRadius: 6,
      yAxisID: 'y1'
    });

    // Custom plugin to draw red background for down periods
    const downBackgroundPlugin = {
      id: 'downBackground',
      beforeDatasetsDraw: function(chart) {
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        const xScale = chart.scales.x;
        
        ctx.save();
        ctx.fillStyle = 'rgba(239, 68, 68, 0.1)'; // Red with transparency
        
        // Find continuous down periods
        let downStart = null;
        for(let i = 0; i < data.statuses.length; i++){
          if(data.statuses[i] === 0){ // Monitor is down
            if(downStart === null){
              downStart = i; // Start of down period
            }
          } else {
            if(downStart !== null){
              // End of down period, draw rectangle
              const x1 = xScale.getPixelForValue(downStart);
              const x2 = xScale.getPixelForValue(i);
              ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
              downStart = null;
            }
          }
        }
        
        // Handle case where chart ends with down status
        if(downStart !== null){
          const x1 = xScale.getPixelForValue(downStart);
          const x2 = chartArea.right;
          ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
        }
        
        ctx.restore();
      }
    };

    const config = {
      type: 'line',
      data: {
        labels: labels,
        datasets: datasets
      },
      plugins: [downBackgroundPlugin],
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e2e8f0',
              font: { size: 12 }
            }
          },
          title: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(24, 24, 24, 0.95)',
            titleColor: '#e2e8f0',
            bodyColor: '#e2e8f0',
            borderColor: 'rgba(160, 160, 160, 0.3)',
            borderWidth: 1,
            callbacks: {
              label: function(context){
                let label = context.dataset.label || '';
                if(label === 'Status'){
                  const status = data.statuses[context.dataIndex];
                  return label + ': ' + (status === 1 ? 'Up' : 'Down');
                }
                if(label && context.parsed.y !== null){
                  return label + ': ' + context.parsed.y.toFixed(2) + ' ms';
                }
                return label;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: { 
              color: '#a1a1aa',
              maxRotation: 45,
              minRotation: 45
            },
            grid: { 
              color: 'rgba(160, 160, 160, 0.1)' 
            }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: {
              display: true,
              text: 'Response Time (ms)',
              color: '#e2e8f0'
            },
            ticks: { 
              color: '#a1a1aa',
              callback: function(value){
                return value.toFixed(0) + ' ms';
              }
            },
            grid: { 
              color: 'rgba(160, 160, 160, 0.1)' 
            }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            min: 0,
            max: 1.5,
            title: {
              display: true,
              text: 'Status',
              color: '#e2e8f0'
            },
            ticks: {
              color: '#a1a1aa',
              stepSize: 1,
              callback: function(value){
                if(value === 1){
                  return 'Up';
                }
                else if(value === 0){
                  return 'Down';
                } else {
                  return '';
                }
              }
            },
            grid: {
              drawOnChartArea: false
            }
          }
        }
      }
    };

    // Create and store chart instance
    chartInstances[data.id] = new Chart(ctx, config);
  }
})();
</script>
{{end}}
