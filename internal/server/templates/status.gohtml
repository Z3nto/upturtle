{{define "status.gohtml"}}
{{template "layout" .}}
{{end}}

{{define "status.content"}}
<style>
#upturtle-tooltip {
  position: fixed;
  display: none;
  background: rgba(24,24,24,0.95);
  border: 1px solid rgba(160,160,160,0.3);
  padding: 0.5rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.875rem;
  color: #e2e8f0;
  z-index: 10000;
  pointer-events: none;
  max-width: 300px;
  word-wrap: break-word;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
</style>
<div class="mb-6">
  <h2 class="text-2xl font-semibold text-gray-100 m-0">Current status</h2>
</div>
{{if .Groups}}
  {{range .Groups}}
    <div class="bg-dark-card backdrop-blur-sm border border-dark-border rounded-lg mb-4 overflow-hidden">
      <div class="px-6 py-4 border-b border-dark-border">
        <h3 class="text-lg font-semibold text-gray-100 m-0">{{if .Name}}{{.Name}}{{else}}Ungrouped{{end}}</h3>
      </div>
      {{if .Monitors}}
      <!-- Desktop Table View -->
      <div class="hidden md:block overflow-x-auto">
        <table class="status-table w-full table-fixed" data-group="{{.Name}}">
          <colgroup>
            <col class="w-auto">
            <col class="w-24">
            <col class="w-20">
            <col class="w-[200px]">
            <col class="w-24">
          </colgroup>
          <thead class="bg-gray-800/30">
            <tr>
              <th class="pl-4 lg:pl-6 pr-2 lg:pr-4 py-2 text-left text-sm font-medium text-gray-300">Name</th>
              <th class="px-2 lg:px-4 py-2 text-left text-sm font-medium text-gray-300">Status</th>
              <th class="px-2 lg:px-4 py-2 text-left text-sm font-medium text-gray-300">Last</th>
              <th class="px-2 lg:px-4 py-2 text-left text-sm font-medium text-gray-300">History</th>
              <th class="pl-2 lg:pl-4 pr-4 lg:pr-6 py-2 text-right text-sm font-medium text-gray-300">Uptime</th>
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-800/50">
            {{range .Monitors}}
            <tr class="monitor-row {{statusClass .Status}} hover:bg-gray-800/30 transition-colors cursor-pointer" data-id="{{.ID}}" data-type="{{.Type}}">
              <td class="pl-4 lg:pl-6 pr-2 lg:pr-4 py-3 max-w-0">
                <div class="font-medium text-gray-200 truncate" title="{{.Name}}">{{.Name}}</div>
                <div class="text-sm text-gray-500 truncate" title="{{.Target}}">
                  {{if or (eq .Type "http") (eq .Type "https")}}
                    <a href="{{.Target}}" target="_blank" rel="noopener noreferrer" class="hover:text-blue-400 hover:underline">{{.Target}}</a>
                  {{else}}
                    {{.Target}}
                  {{end}}
                </div>
              </td>
              <td class="px-2 lg:px-4 py-3">
                {{if not .Enabled}}
                  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-800/50 text-gray-400 border border-gray-700/50">Disabled</span>
                {{else}}
                  {{if .MasterDown}}
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50" data-tip="Master monitor is down">Master down</span>
                  {{else}}
                    {{if eq .Status "up"}}
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-900/50 text-green-300 border border-green-700/50" data-field="status">{{.Status}}</span>
                    {{else if eq .Status "down"}}
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-900/50 text-red-300 border border-red-700/50" data-field="status">{{.Status}}</span>
                    {{else}}
                      <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50" data-field="status">{{.Status}}</span>
                    {{end}}
                  {{end}}
                {{end}}
              </td>
              <td class="px-2 lg:px-4 py-3">
                <span class="text-sm text-gray-400" data-field="last-checked-rel">{{formatRelative .LastChecked}}</span>
              </td>
              <td class="px-2 lg:px-4 py-3">
                <div class="history flex gap-0.5" data-field="history">
                  {{range .History}}
                    {{if .Success}}
                      <span class="up w-2 h-5 bg-green-500 rounded-sm" data-tip="{{formatTime .Timestamp}} · OK"></span>
                    {{else}}
                      <span class="down w-2 h-5 bg-red-500 rounded-sm" data-tip="{{formatTime .Timestamp}} · {{.Message}}"></span>
                    {{end}}
                  {{end}}
                </div>
              </td>
              <td class="pl-2 lg:pl-4 pr-4 lg:pr-6 py-3 text-right"><span class="text-sm text-gray-300" data-field="uptime">{{printf "%.1f" .SuccessRate}}%</span></td>
            </tr>
            <tr class="chart-row" data-monitor-id="{{.ID}}" style="display: none;">
              <td colspan="5" class="p-0">
                <div class="chart-container overflow-hidden" style="height: 0; transition: height 0.3s ease;">
                  <div class="chart-content p-6">
                    <div class="chart-loading text-gray-400 text-center py-8">Loading chart data...</div>
                    <canvas class="monitor-chart" style="display: none; height: 375px;"></canvas>
                  </div>
                </div>
              </td>
            </tr>
            {{end}}
          </tbody>
        </table>
      </div>
      
      <!-- Mobile Card View -->
      <div class="md:hidden space-y-4 p-4">
        {{range .Monitors}}
        <div class="mobile-monitor-wrapper">
          <div class="monitor-row {{statusClass .Status}} bg-gray-800/30 border border-gray-700/50 rounded-lg p-4 hover:bg-gray-800/50 transition-colors cursor-pointer" data-id="{{.ID}}" data-type="{{.Type}}">
            <!-- Monitor Name -->
            <div class="mb-3 pb-3 border-b border-gray-700/50">
              <div class="text-xs font-semibold text-gray-400 uppercase mb-1">Monitor</div>
              <div class="font-medium text-gray-200 truncate" title="{{.Name}}">{{.Name}}</div>
              <div class="text-sm text-gray-500 truncate" title="{{.Target}}">
                {{if or (eq .Type "http") (eq .Type "https")}}
                  <a href="{{.Target}}" target="_blank" rel="noopener noreferrer" class="hover:text-blue-400 hover:underline">{{.Target}}</a>
                {{else}}
                  {{.Target}}
                {{end}}
              </div>
            </div>
            
            <!-- Status -->
            <div class="mb-3">
              <div class="text-xs font-semibold text-gray-400 uppercase mb-1">Status</div>
              {{if not .Enabled}}
                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-800/50 text-gray-400 border border-gray-700/50">Disabled</span>
              {{else}}
                {{if .MasterDown}}
                  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50" data-tip="Master monitor is down">Master down</span>
                {{else}}
                  {{if eq .Status "up"}}
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-900/50 text-green-300 border border-green-700/50" data-field="status">{{.Status}}</span>
                  {{else if eq .Status "down"}}
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-900/50 text-red-300 border border-red-700/50" data-field="status">{{.Status}}</span>
                  {{else}}
                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50" data-field="status">{{.Status}}</span>
                  {{end}}
                {{end}}
              {{end}}
            </div>
            
            <!-- Last Checked -->
            <div class="mb-3">
              <div class="text-xs font-semibold text-gray-400 uppercase mb-1">Last Checked</div>
              <span class="text-sm text-gray-400" data-field="last-checked-rel">{{formatRelative .LastChecked}}</span>
            </div>
            
            <!-- History -->
            <div class="mb-3">
              <div class="text-xs font-semibold text-gray-400 uppercase mb-1">History</div>
              <div class="history flex gap-0.5" data-field="history">
                {{range .History}}
                  {{if .Success}}
                    <span class="up w-2 h-5 bg-green-500 rounded-sm" data-tip="{{formatTime .Timestamp}} · OK"></span>
                  {{else}}
                    <span class="down w-2 h-5 bg-red-500 rounded-sm" data-tip="{{formatTime .Timestamp}} · {{.Message}}"></span>
                  {{end}}
                {{end}}
              </div>
            </div>
            
            <!-- Uptime -->
            <div>
              <div class="text-xs font-semibold text-gray-400 uppercase mb-1">Uptime</div>
              <span class="text-sm text-gray-300" data-field="uptime">{{printf "%.1f" .SuccessRate}}%</span>
            </div>
          </div>
          
          <!-- Chart Row for Mobile -->
          <div class="chart-row bg-gray-800/30 border border-gray-700/50 border-t-0 rounded-b-lg" data-monitor-id="{{.ID}}" style="display: none;">
            <div class="chart-container overflow-hidden" style="height: 0; transition: height 0.3s ease;">
              <div class="chart-content p-4">
                <div class="chart-loading text-gray-400 text-center py-8">Loading chart data...</div>
                <canvas class="monitor-chart" style="display: none; height: 375px;"></canvas>
              </div>
            </div>
          </div>
        </div>
        {{end}}
      </div>
      {{else}}
        <p class="text-gray-400 text-center py-8">No monitors in this group.</p>
      {{end}}
    </div>
  {{end}}
{{else}}
  <p class="text-gray-400 text-center py-8">No monitors configured yet. Visit the admin area to create one.</p>
{{end}}
<script>
(function(){
  // Simple tooltip for elements with [data-tip]
  let tipEl;
  function ensureTip(){
    if(!tipEl){
      tipEl = document.createElement('div');
      tipEl.id = 'upturtle-tooltip';
      document.body.appendChild(tipEl);
    }
    return tipEl;
  }
  function showTip(text, x, y){
    const el = ensureTip();
    el.textContent = String(text || '');
    el.style.display = 'block';
    // Position with viewport bounds checking
    const margin = 10;
    const rect = { w: el.offsetWidth, h: el.offsetHeight };
    let left = x + 12;
    let top = y + 12;
    if(left + rect.w + margin > window.innerWidth){ left = x - rect.w - 12; }
    if(top + rect.h + margin > window.innerHeight){ top = y - rect.h - 12; }
    el.style.left = Math.max(margin, left) + 'px';
    el.style.top = Math.max(margin, top) + 'px';
  }
  function hideTip(){ if(tipEl){ tipEl.style.display = 'none'; } }
  let currentTarget = null;
  document.addEventListener('mouseover', function(ev){
    const t = ev.target.closest('[data-tip]');
    if(t){ currentTarget = t; showTip(t.getAttribute('data-tip'), ev.clientX, ev.clientY); }
  });
  document.addEventListener('mousemove', function(ev){ if(currentTarget){ showTip(currentTarget.getAttribute('data-tip'), ev.clientX, ev.clientY); } });
  document.addEventListener('mouseout', function(ev){
    if(currentTarget && !ev.relatedTarget){ currentTarget = null; hideTip(); return; }
    if(currentTarget && !ev.relatedTarget?.closest('[data-tip]')){ currentTarget = null; hideTip(); }
  });
})();
</script>
<div id="refresh-control" class="fixed left-3 bottom-3 bg-[rgba(24,24,24,0.85)] border border-dark-border px-3 py-2 rounded-lg text-sm text-gray-300 flex items-center gap-2 backdrop-blur-sm">
  <label for="refresh-select">Refresh:</label>
  <select id="refresh-select" class="bg-gray-800/50 border border-gray-700 rounded px-2 py-1 text-gray-200 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
    <option value="5000">5s</option>
    <option value="10000" selected>10s</option>
    <option value="15000">15s</option>
    <option value="30000">30s</option>
    <option value="60000">60s</option>
  </select>
  <span class="text-gray-400">auto refresh</span>
</div>
<script>
(function(){
  const KEY = 'upturtle_status_poll_ms';
  function getPollMs(){
    const v = localStorage.getItem(KEY);
    const n = parseInt(v||'10000', 10);
    if (!isFinite(n) || n < 1000) return 10000;
    return n;
  }
  function setPollMs(n){ localStorage.setItem(KEY, String(n)); }
  function initControl(){
    const sel = document.getElementById('refresh-select');
    if(!sel) return;
    const current = getPollMs();
    for(const o of sel.options){ if(parseInt(o.value,10)===current){ o.selected = true; break; } }
    sel.addEventListener('change', function(){
      const n = parseInt(sel.value,10); setPollMs(n);
    });
  }
  function statusClass(s){
    if(s === 'up') return 'status-up';
    if(s === 'down') return 'status-down';
    return 'status-unknown';
  }
  const HISTORY_PREVIEW = 20;
  function formatDuration(ms){
    if(ms <= 0) return '-';
    if(ms < 1000) return Math.round(ms) + 'ms';
    return (ms/1000).toFixed(3) + 's';
  }
  function formatAbs(ts){
    if(!ts) return '-';
    const d = new Date(ts);
    if(isNaN(d.getTime())) return '-';
    return d.toLocaleString();
  }
  function formatRel(ts){
    if(!ts) return '';
    const d = new Date(ts);
    if(isNaN(d.getTime())) return '';
    const diff = Date.now() - d.getTime();
    // If more than 365 days ago, treat as no data
    if(diff > 365 * 24 * 60 * 60 * 1000) return '';
    const s = Math.max(1, Math.floor(diff/1000));
    if(s < 60) return s + 's ago';
    const m = Math.floor(s/60); if(m < 60) return m + 'm ago';
    const h = Math.floor(m/60); if(h < 24) return h + 'h ago';
    const ddays = Math.floor(h/24); return ddays + 'd ago';
  }
  let timer = null; let running = false;

  function renderHistoryHTML(arr){
    const items = Array.isArray(arr) ? arr : [];
    const real = items.map(h => {
      const tipText = formatAbs(h.timestamp) + ' · ' + (h.success ? 'OK' : (h.message || ''));
      const encodedTip = btoa(encodeURIComponent(tipText));
      const className = h.success ? 'up w-2 h-5 bg-green-500 rounded-sm' : 'down w-2 h-5 bg-red-500 rounded-sm';
      // include data-ts for incremental updates
      return `<span class="${className}" data-ts="${String(h.timestamp)}" data-tip-encoded="${encodedTip}" onmouseover="this.setAttribute('data-tip', decodeURIComponent(atob(this.getAttribute('data-tip-encoded'))))"></span>`;
    });
    const placeholders = [];
    const need = Math.max(0, HISTORY_PREVIEW - real.length);
    for (let i = 0; i < need; i++) {
      placeholders.push('<span class="unknown w-2 h-5 bg-gray-700 rounded-sm" data-tip="unknown"></span>');
    }
    // unknown placeholders should be on the LEFT of the real values
    return placeholders.join('') + real.join('');
  }

  function padExistingHistories(){
    document.querySelectorAll('.history').forEach(el => {
      const current = el.children.length;
      const need = Math.max(0, HISTORY_PREVIEW - current);
      for(let i=0; i < need; i++){
        const sp = document.createElement('span');
        sp.className = 'unknown w-2 h-5 bg-gray-700 rounded-sm';
        sp.setAttribute('data-tip', 'unknown');
        el.insertBefore(sp, el.firstChild);
      }
    });
  }
  // Create a history span DOM node from a history item
  function createHistorySpan(h){
    const tipText = formatAbs(h.timestamp) + ' · ' + (h.success ? 'OK' : (h.message || ''));
    const encodedTip = btoa(encodeURIComponent(tipText));
    const sp = document.createElement('span');
    sp.className = h.success ? 'up w-2 h-5 bg-green-500 rounded-sm' : 'down w-2 h-5 bg-red-500 rounded-sm';
    sp.setAttribute('data-ts', String(h.timestamp));
    sp.setAttribute('data-tip-encoded', encodedTip);
    sp.onmouseover = function(){
      this.setAttribute('data-tip', decodeURIComponent(atob(this.getAttribute('data-tip-encoded'))));
    };
    return sp;
  }
  // Incrementally update history: append new items (by timestamp) and remove oldest to keep length
  function updateHistoryIncremental(histEl, incoming){
    if(!histEl) return;
    const items = Array.isArray(incoming) ? incoming : [];
    if(items.length === 0) return;

    // Determine last known timestamp on the RIGHT-most real item
    let lastKnownTs = null;
    for(let i = histEl.children.length - 1; i >= 0; i--){
      const ch = histEl.children[i];
      const ts = ch.getAttribute && ch.getAttribute('data-ts');
      if(ts){ lastKnownTs = ts; break; }
    }

    // If no timestamps in DOM (first-time or server-rendered), full render
    if(!lastKnownTs){
      histEl.innerHTML = renderHistoryHTML(items);
      return;
    }

    // Collect new items strictly newer than lastKnownTs, in correct order
    const toAppend = [];
    for(let i = 0; i < items.length; i++){
      const it = items[i];
      if(String(it.timestamp) > String(lastKnownTs)){
        toAppend.push(it);
      }
    }
    if(toAppend.length === 0){
      return; // nothing new
    }

    // Append new ones to the right
    toAppend.forEach(h => {
      histEl.appendChild(createHistorySpan(h));
    });

    // Ensure length: remove from left first real or unknowns to maintain HISTORY_PREVIEW
    // Compute excess
    let total = histEl.children.length;
    const maxLen = HISTORY_PREVIEW;
    while(total > maxLen){
      if(histEl.firstChild){ histEl.removeChild(histEl.firstChild); total--; } else { break; }
    }
  }
  async function poll(){
    try {
      const res = await fetch('/api/status', { cache: 'no-store', redirect: 'follow', credentials: 'same-origin' });
      // If session expired, the server redirects to /login; detect and navigate
      if (res.redirected || (res.url && res.url.indexOf('/login') !== -1)) {
        window.location.href = '/login';
        return;
      }
      if (res.status === 401 || res.status === 403) {
        window.location.href = '/login';
        return;
      }
      const ct = res.headers.get('content-type') || '';
      if (ct.indexOf('application/json') === -1) {
        // Likely got HTML (e.g., login page). Redirect to login.
        window.location.href = '/login';
        return;
      }
      if(!res.ok) throw new Error('http '+res.status);
      const data = await res.json();
      const byId = {};
      data.forEach(x => { byId[x.id] = x; });
      // Update both desktop table rows and mobile cards
      document.querySelectorAll('.monitor-row[data-id]').forEach(row => {
        const id = row.getAttribute('data-id');
        const it = byId[id];
        if(!it) return;

        // Always update row class (cheap) and master-dependent status badge
        row.classList.remove('status-up','status-down','status-unknown');
        row.classList.add(statusClass(it.status));
        const statusCell = row.querySelector('[data-field="status"]');
        const isMasterDown = !!(it.master_id && byId[it.master_id] && byId[it.master_id].status === 'down');
        
        if(isMasterDown){
          // For desktop table, update the td container
          const statusContainer = row.querySelector('td:nth-child(2)');
          if(statusContainer){ 
            statusContainer.innerHTML = '<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50" data-tip="Master monitor is down">Master down<\/span>'; 
          }
          // For mobile cards, update the status badge directly
          if(statusCell && !statusContainer){
            statusCell.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50';
            statusCell.textContent = 'Master down';
            statusCell.setAttribute('data-tip', 'Master monitor is down');
          }
        } else if(statusCell){
          // Update badge with Tailwind classes
          if(it.status === 'up'){
            statusCell.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-900/50 text-green-300 border border-green-700/50';
          } else if(it.status === 'down'){
            statusCell.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-900/50 text-red-300 border border-red-700/50';
          } else {
            statusCell.className = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-700/50 text-gray-300 border border-gray-600/50';
          }
          statusCell.textContent = it.status;
        }

        // Always refresh relative time text
        const relEl = row.querySelector('[data-field="last-checked-rel"]');
        if(relEl) relEl.textContent = formatRel(it.last_checked);

        // History and uptime: initialize once, then incremental updates only when new data
        const histEl = row.querySelector('[data-field="history"]');
        const upEl = row.querySelector('[data-field="uptime"]');
        const initialized = row.getAttribute('data-init') === '1';
        if(!initialized){
          if(histEl && Array.isArray(it.history)){
            histEl.innerHTML = renderHistoryHTML(it.history);
          }
          if(upEl && Array.isArray(it.history) && it.history.length){
            const ok = it.history.filter(h => h.success).length;
            upEl.textContent = ((ok / it.history.length) * 100).toFixed(1) + '%';
          }
          row.setAttribute('data-last-checked', String(it.last_checked || ''));
          row.setAttribute('data-init', '1');
        } else {
          const prevLC = row.getAttribute('data-last-checked') || '';
          const currLC = String(it.last_checked || '');
          if(prevLC !== currLC){
            // Incremental history update
            if(histEl && Array.isArray(it.history)){
              updateHistoryIncremental(histEl, it.history);
            }
            // Recompute uptime from current 20-window
            if(upEl){
              const children = histEl ? Array.from(histEl.children) : [];
              if(children.length){
                const total = Math.min(children.length, HISTORY_PREVIEW);
                let okCount = 0;
                for(const ch of children){ if(ch.classList.contains('up')) okCount++; }
                upEl.textContent = ((okCount / total) * 100).toFixed(1) + '%';
              }
            }
            row.setAttribute('data-last-checked', currLC);
          }
        }
      });
    } catch(e) { /* ignore transient errors */ }
    finally {
      const next = getPollMs();
      timer = setTimeout(poll, next);
    }
  }
  initControl();
  padExistingHistories();
  poll();
  // React to user changes immediately
  const sel = document.getElementById('refresh-select');
  if(sel){ sel.addEventListener('change', function(){ if(timer){ clearTimeout(timer); } poll(); }); }
})();

// Chart expansion functionality
(function(){
  let currentOpenMonitorId = null;
  let chartInstances = {}; // Store chart instances to destroy them later
  let animationTimeouts = {}; // Store animation timeouts to cancel them
  let isAnimating = {}; // Track which monitors are currently animating

  // Handle monitor row clicks
  document.addEventListener('click', function(ev){
    const monitorRow = ev.target.closest('.monitor-row');
    if(!monitorRow) return;

    const monitorId = monitorRow.getAttribute('data-id');
    const monitorType = monitorRow.getAttribute('data-type');
    
    console.log('Monitor clicked:', monitorId, monitorType);
    
    // Prevent multiple clicks during animation
    if(isAnimating[monitorId]) return;
    
    // If clicking the same row, close it
    if(currentOpenMonitorId === monitorId){
      closeChart(monitorId);
      currentOpenMonitorId = null;
      return;
    }

    // If another chart is open, close it first
    if(currentOpenMonitorId){
      closeChart(currentOpenMonitorId);
    }

    // Open the new chart
    openChart(monitorId, monitorType);
    currentOpenMonitorId = monitorId;
  });

  // Close chart when viewport crosses the mobile/desktop breakpoint
  let lastWasMobile = window.innerWidth < 768;
  window.addEventListener('resize', function() {
    const isMobile = window.innerWidth < 768;
    // Only close if we crossed the breakpoint
    if (isMobile !== lastWasMobile) {
      if (currentOpenMonitorId) {
        // Close chart on the old viewport type
        closeChartImmediate(currentOpenMonitorId, lastWasMobile);
        currentOpenMonitorId = null;
      }
      lastWasMobile = isMobile;
    }
  });

  // Immediate close without animation (for viewport switch)
  function closeChartImmediate(monitorId, wasMobile) {
    const allChartRows = document.querySelectorAll(`.chart-row[data-monitor-id="${monitorId}"]`);
    for(const row of allChartRows) {
      const isDesktopRow = row.tagName === 'TR';
      const isMobileRow = row.tagName === 'DIV' && row.closest('.mobile-monitor-wrapper');
      
      if((wasMobile && isMobileRow) || (!wasMobile && isDesktopRow)) {
        row.style.display = 'none';
        const container = row.querySelector('.chart-container');
        if(container) container.style.height = '0';
        if(chartInstances[monitorId]) {
          chartInstances[monitorId].destroy();
          delete chartInstances[monitorId];
        }
        break;
      }
    }
  }

  function openChart(monitorId, monitorType){
    console.log('Opening chart for monitor:', monitorId);
    
    // Find all chart rows with this monitor ID
    const allChartRows = document.querySelectorAll(`.chart-row[data-monitor-id="${monitorId}"]`);
    console.log('Found chart rows:', allChartRows.length);
    
    // Determine if we're on mobile or desktop based on viewport width
    const isMobile = window.innerWidth < 768; // md breakpoint
    
    // Find the appropriate chart row based on viewport
    let chartRow = null;
    for(const row of allChartRows) {
      // Desktop: TR element (inside table)
      // Mobile: DIV element (inside mobile-monitor-wrapper)
      const isDesktopRow = row.tagName === 'TR';
      const isMobileRow = row.tagName === 'DIV' && row.closest('.mobile-monitor-wrapper');
      
      if(isMobile && isMobileRow) {
        chartRow = row;
        break;
      } else if(!isMobile && isDesktopRow) {
        chartRow = row;
        break;
      }
    }
    
    if(!chartRow) {
      console.error('No chart row found for monitor', monitorId, 'isMobile:', isMobile);
      return;
    }
    console.log('Using chart row:', chartRow.tagName, 'isMobile:', isMobile);

    const container = chartRow.querySelector('.chart-container');
    const loading = chartRow.querySelector('.chart-loading');
    const canvas = chartRow.querySelector('.monitor-chart');

    if(!container) {
      console.error('Chart container not found for monitor', monitorId);
      return;
    }
    console.log('Chart container found, animating...');

    // Cancel any pending animation timeout for this monitor
    if(animationTimeouts[monitorId]){
      clearTimeout(animationTimeouts[monitorId]);
      delete animationTimeouts[monitorId];
    }

    // Mark as animating
    isAnimating[monitorId] = true;

    // Show the chart row first - use table-row for <tr>, block for <div>
    if(chartRow.tagName === 'TR') {
      chartRow.style.display = 'table-row';
    } else {
      chartRow.style.display = 'block';
    }
    
    // Force reflow to ensure transition works
    container.style.transition = 'none';
    container.style.height = '0';
    
    // Force reflow
    void container.offsetHeight;
    
    // Re-enable transition and animate
    container.style.transition = 'height 0.3s ease';
    container.style.height = '400px';

    // Show loading state
    loading.style.display = 'block';
    canvas.style.display = 'none';

    // Mark animation as complete after transition
    animationTimeouts[monitorId] = setTimeout(function(){
      isAnimating[monitorId] = false;
      delete animationTimeouts[monitorId];
    }, 300);

    // Fetch chart data
    fetch(`/api/monitors/chart/${monitorId}`)
      .then(res => {
        if(!res.ok) throw new Error('Failed to fetch chart data');
        return res.json();
      })
      .then(data => {
        loading.style.display = 'none';
        canvas.style.display = 'block';
        renderChart(canvas, data, monitorType);
      })
      .catch(err => {
        console.error('Error loading chart:', err);
        loading.textContent = 'Error loading chart data';
      });
  }

  function closeChart(monitorId){
    // Find the appropriate chart row based on viewport
    const isMobile = window.innerWidth < 768;
    const allChartRows = document.querySelectorAll(`.chart-row[data-monitor-id="${monitorId}"]`);
    
    let chartRow = null;
    for(const row of allChartRows) {
      const isDesktopRow = row.tagName === 'TR';
      const isMobileRow = row.tagName === 'DIV' && row.closest('.mobile-monitor-wrapper');
      
      if(isMobile && isMobileRow) {
        chartRow = row;
        break;
      } else if(!isMobile && isDesktopRow) {
        chartRow = row;
        break;
      }
    }
    
    if(!chartRow) return;

    const container = chartRow.querySelector('.chart-container');
    const loading = chartRow.querySelector('.chart-loading');
    const canvas = chartRow.querySelector('.monitor-chart');

    // Cancel any pending animation timeout for this monitor
    if(animationTimeouts[monitorId]){
      clearTimeout(animationTimeouts[monitorId]);
      delete animationTimeouts[monitorId];
    }

    // Mark as animating
    isAnimating[monitorId] = true;

    // Destroy chart instance if exists
    if(chartInstances[monitorId]){
      chartInstances[monitorId].destroy();
      delete chartInstances[monitorId];
    }

    // Animate height to 0
    container.style.transition = 'height 0.3s ease';
    container.style.height = '0';

    // After animation, hide row and reset content
    animationTimeouts[monitorId] = setTimeout(function(){
      chartRow.style.display = 'none';
      loading.style.display = 'block';
      loading.textContent = 'Loading chart data...';
      canvas.style.display = 'none';
      isAnimating[monitorId] = false;
      delete animationTimeouts[monitorId];
    }, 300);
  }

  function renderChart(canvas, data, monitorType){
    const ctx = canvas.getContext('2d');
    
    // Destroy existing chart if any
    if(chartInstances[data.id]){
      chartInstances[data.id].destroy();
    }

    // Format timestamps for display - show date only once per day
    const labels = data.timestamps.map((ts, i) => {
      const d = new Date(ts);
      const prevD = i > 0 ? new Date(data.timestamps[i - 1]) : null;
      
      // Check if this is a new day
      const isNewDay = !prevD || 
                       d.getDate() !== prevD.getDate() || 
                       d.getMonth() !== prevD.getMonth() || 
                       d.getFullYear() !== prevD.getFullYear();
      
      if(isNewDay){
        // Show full date and time for first entry of the day
        return d.toLocaleString('de-DE', { 
          day: '2-digit',
          month: '2-digit',
          hour: '2-digit', 
          minute: '2-digit' 
        });
      } else {
        // Show only time for subsequent entries
        return d.toLocaleTimeString('de-DE', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
      }
    });

    // Create datasets based on monitor type
    const datasets = [];

    // For all monitor types, show latency (only when status is up)
    datasets.push({
      label: 'Response Time (ms)',
      data: data.latencies.map((lat, i) => data.statuses[i] === 1 ? lat : null),
      borderColor: '#3b82f6',
      backgroundColor: 'rgba(59, 130, 246, 0.1)',
      borderWidth: 2,
      fill: true,
      tension: 0.4,
      pointRadius: 0,
      pointHoverRadius: 0,
      spanGaps: false,
      yAxisID: 'y'
    });

    // Add status as a separate dataset on secondary y-axis
    datasets.push({
      label: 'Status',
      data: data.statuses,
      borderColor: '#34d399',
      backgroundColor: 'rgba(52, 211, 153, 0.1)',
      borderWidth: 2,
      fill: false,
      stepped: true,
      pointRadius: 0,
      pointHoverRadius: 6,
      yAxisID: 'y1'
    });

    // Custom plugin to draw red background for down periods
    const downBackgroundPlugin = {
      id: 'downBackground',
      beforeDatasetsDraw: function(chart) {
        const ctx = chart.ctx;
        const chartArea = chart.chartArea;
        const xScale = chart.scales.x;
        
        ctx.save();
        ctx.fillStyle = 'rgba(239, 68, 68, 0.1)'; // Red with transparency
        
        // Find continuous down periods
        let downStart = null;
        for(let i = 0; i < data.statuses.length; i++){
          if(data.statuses[i] === 0){ // Monitor is down
            if(downStart === null){
              downStart = i; // Start of down period
            }
          } else {
            if(downStart !== null){
              // End of down period, draw rectangle
              const x1 = xScale.getPixelForValue(downStart);
              const x2 = xScale.getPixelForValue(i);
              ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
              downStart = null;
            }
          }
        }
        
        // Handle case where chart ends with down status
        if(downStart !== null){
          const x1 = xScale.getPixelForValue(downStart);
          const x2 = chartArea.right;
          ctx.fillRect(x1, chartArea.top, x2 - x1, chartArea.bottom - chartArea.top);
        }
        
        ctx.restore();
      }
    };

    const config = {
      type: 'line',
      data: {
        labels: labels,
        datasets: datasets
      },
      plugins: [downBackgroundPlugin],
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'index',
          intersect: false
        },
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e2e8f0',
              font: { size: 12 }
            }
          },
          title: {
            display: false
          },
          tooltip: {
            backgroundColor: 'rgba(24, 24, 24, 0.95)',
            titleColor: '#e2e8f0',
            bodyColor: '#e2e8f0',
            borderColor: 'rgba(160, 160, 160, 0.3)',
            borderWidth: 1,
            callbacks: {
              label: function(context){
                let label = context.dataset.label || '';
                if(label === 'Status'){
                  const status = data.statuses[context.dataIndex];
                  return label + ': ' + (status === 1 ? 'Up' : 'Down');
                }
                if(label && context.parsed.y !== null){
                  return label + ': ' + context.parsed.y.toFixed(2) + ' ms';
                }
                return label;
              }
            }
          }
        },
        scales: {
          x: {
            ticks: { 
              color: '#a1a1aa',
              maxRotation: 45,
              minRotation: 45
            },
            grid: { 
              color: 'rgba(160, 160, 160, 0.1)' 
            }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            title: {
              display: true,
              text: 'Response Time (ms)',
              color: '#e2e8f0'
            },
            ticks: { 
              color: '#a1a1aa',
              callback: function(value){
                return value.toFixed(0) + ' ms';
              }
            },
            grid: { 
              color: 'rgba(160, 160, 160, 0.1)' 
            }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            min: 0,
            max: 1.5,
            title: {
              display: true,
              text: 'Status',
              color: '#e2e8f0'
            },
            ticks: {
              color: '#a1a1aa',
              stepSize: 1,
              callback: function(value){
                if(value === 1){
                  return 'Up';
                }
                else if(value === 0){
                  return 'Down';
                } else {
                  return '';
                }
              }
            },
            grid: {
              drawOnChartArea: false
            }
          }
        }
      }
    };

    // Create and store chart instance
    chartInstances[data.id] = new Chart(ctx, config);
  }
})();
</script>
{{end}}
