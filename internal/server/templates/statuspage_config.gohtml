{{define "statuspage_config.gohtml"}}
{{template "layout" .}}
{{end}}

{{define "statuspage_config.content"}}
<div>
    <div class="flex items-start justify-between mb-6">
        <div>
            <h2 class="text-2xl font-semibold text-gray-100 m-0">Configure: {{.StatusPage.Name}}</h2>
            <p class="text-gray-400 text-sm mt-1">URL: <code class="bg-gray-800/50 px-1.5 py-0.5 rounded text-gray-300">/status/{{.StatusPage.Slug}}</code></p>
        </div>
        <a href="/admin/statuspages" class="no-underline">
            <button type="button" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-200 font-medium rounded-lg transition-colors">← Back</button>
        </a>
    </div>

    {{if .Success}}<div class="mb-4 p-4 bg-green-900/30 border border-green-700/50 text-green-300 rounded-lg">{{.Success}}</div>{{end}}
    {{if .Error}}<div class="mb-4 p-4 bg-red-900/30 border border-red-700/50 text-red-300 rounded-lg">{{.Error}}</div>{{end}}

    <form id="form-configure-statuspage">
        <div class="bg-dark-card backdrop-blur-sm border border-dark-border rounded-lg p-6 mb-4">
            <h3 class="text-lg font-semibold text-gray-100 mb-4">Basic Settings</h3>
            <div class="mb-4">
                <label for="statuspage-name" class="block text-sm font-medium text-gray-300 mb-2">Name *</label>
                <input type="text" id="statuspage-name" name="name" value="{{.StatusPage.Name}}" required class="w-full px-4 py-2 bg-gray-800/50 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors">
            </div>
            <div class="mb-4">
                <label for="statuspage-slug" class="block text-sm font-medium text-gray-300 mb-2">URL Slug *</label>
                <input type="text" id="statuspage-slug" name="slug" value="{{.StatusPage.Slug}}" required pattern="[a-z0-9\-]+" class="w-full px-4 py-2 bg-gray-800/50 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors">
                <small class="text-gray-500 text-sm mt-1 block">Only lowercase letters, numbers, and hyphens</small>
            </div>
            <div>
                <label class="flex items-center gap-2 text-gray-300 cursor-pointer hover:text-white transition-colors">
                    <input type="checkbox" name="active" value="true" {{if .StatusPage.Active}}checked{{end}} class="w-4 h-4 rounded border-gray-600 bg-gray-700 text-blue-600 focus:ring-2 focus:ring-blue-500 focus:ring-offset-0">
                    <span>Active (page is publicly accessible)</span>
                </label>
            </div>
        </div>

        <div class="bg-dark-card backdrop-blur-sm border border-dark-border rounded-lg p-6 mb-4">
            <h3 class="text-lg font-semibold text-gray-100 mb-2">Monitors & Groups</h3>
            <p class="text-gray-400 text-sm mb-4">Select which monitors to display on this status page and organize them into custom groups.</p>
            
            <div class="mb-4">
                <button type="button" id="btn-add-statuspage-group" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors">+ Add Group</button>
            </div>
            
            <div id="statuspage-groups" class="mb-6">
                <!-- Groups will be populated by JavaScript -->
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="border border-dark-border rounded-lg p-4 min-h-[300px] bg-gray-900/30">
                    <h4 class="text-sm font-semibold text-gray-300 mb-3">Available Monitors</h4>
                    <div class="flex flex-col gap-2" id="available-monitors">
                        {{range .AllMonitors}}
                        <div class="flex items-center gap-2 p-2 bg-gray-800/50 rounded-lg" data-monitor-id="{{.Config.ID}}" data-monitor-name="{{.Config.Name}}" data-monitor-group="{{.Config.GroupID}}">
                            <span class="flex-1 text-gray-200">{{.Config.Name}}</span>
                            <span class="text-xs px-2 py-0.5 bg-gray-700/50 rounded text-gray-400">{{.Config.Group}}</span>
                            <button type="button" class="w-7 h-7 flex items-center justify-center bg-green-600 hover:bg-green-700 text-white rounded transition-colors text-lg font-light" data-action="add-monitor">+</button>
                        </div>
                        {{end}}
                    </div>
                </div>

                <div class="border border-dark-border rounded-lg p-4 min-h-[300px] bg-gray-900/30">
                    <h4 class="text-sm font-semibold text-gray-300 mb-3">Selected Monitors</h4>
                    <div id="selected-monitors">
                        <!-- Will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <div class="flex justify-end gap-2">
            <button type="button" onclick="window.location.href='/admin/statuspages'" class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-gray-200 font-medium rounded-lg transition-colors">Cancel</button>
            <button type="submit" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-lg transition-colors">Save Configuration</button>
        </div>
    </form>
</div>

<script>
(function(){
  // Initialize with existing monitors - direct JSON embedding
  const statusPageMonitors = {{.StatusPage.Monitors | jsonEscape}} || [];
  const allMonitors = {{.AllMonitors | jsonEscape}} || [];
  const defaultGroups = {{.Groups | jsonEscape}} || [];
  const loadedStatusPageGroups = {{.StatusPageGroups | jsonEscape}} || [];
  
  // Track statuspage-specific groups and selected monitors
  let statuspageGroups = [...loadedStatusPageGroups];
  let selectedMonitors = new Map();
  let nextGroupId = statuspageGroups.length > 0 ? Math.min(...statuspageGroups.map(g => g.id)) - 1 : -1;

  // Initialize selected monitors from status page config
  statusPageMonitors.forEach(spm => {
    const monitor = allMonitors.find(m => m.config && m.config.id === spm.monitor_id);
    if (monitor) {
      selectedMonitors.set(spm.monitor_id, {
        id: spm.monitor_id,
        name: monitor.config.name,
        groupId: spm.group_id,
        order: spm.order || 0
      });
    }
  });

  // Event delegation for add buttons
  document.getElementById('available-monitors').addEventListener('click', function(e) {
    if (e.target.closest('[data-action="add-monitor"]')) {
      const btn = e.target.closest('[data-action="add-monitor"]');
      const item = btn.closest('[data-monitor-id]');
      const id = item.dataset.monitorId;
      const name = item.dataset.monitorName;
      
      // Check if statuspage groups exist
      if (statuspageGroups.length === 0) {
        alert('Please create at least one group first before adding monitors.');
        return;
      }
      
      if (!selectedMonitors.has(id)) {
        // Use first statuspage group as default
        const defaultGroupId = statuspageGroups[0].id;
        selectedMonitors.set(id, {
          id: id,
          name: name,
          groupId: defaultGroupId,
          order: selectedMonitors.size
        });
        renderSelectedMonitors();
        updateAvailableMonitors();
      }
    }
  });

  // Global functions for inline handlers in dynamically generated content
  window.removeMonitorFromStatusPage = function(id) {
    selectedMonitors.delete(id);
    renderSelectedMonitors();
    updateAvailableMonitors();
  };

  window.updateMonitorGroup = function(id, groupId) {
    const monitor = selectedMonitors.get(id);
    if (monitor) {
      monitor.groupId = parseInt(groupId);
      selectedMonitors.set(id, monitor);
    }
  };

  function renderStatuspageGroups() {
    const container = document.getElementById('statuspage-groups');
    if (statuspageGroups.length === 0) {
      container.innerHTML = '<p class="text-gray-400 text-sm">No custom groups yet. Add groups to organize monitors on this status page.</p>';
      return;
    }
    
    container.innerHTML = statuspageGroups.map(g => `
      <div class="flex items-center gap-2 p-2 bg-gray-800/50 rounded-lg mb-2">
        <span class="flex-1 text-gray-200">${escapeHtml(g.name)}</span>
        <button type="button" class="p-1.5 text-gray-400 hover:text-red-400 hover:bg-red-900/20 rounded transition-colors" onclick="deleteStatuspageGroup(${g.id})" title="Delete group">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M3 6h18v2H3V6zm2 3h14l-1.5 12.5A2 2 0 0 1 15.5 24h-7a2 2 0 0 1-1.99-1.5L5 9zm5-6h4l1 1h5v2H4V4h5l1-1z"/>
          </svg>
        </button>
      </div>
    `).join('');
  }
  
  function renderSelectedMonitors() {
    const container = document.getElementById('selected-monitors');
    if (selectedMonitors.size === 0) {
      container.innerHTML = '<p class="text-gray-400 text-sm">No monitors selected yet.</p>';
      return;
    }

    const monitorsArray = Array.from(selectedMonitors.values());
    monitorsArray.sort((a, b) => a.order - b.order);

    container.innerHTML = monitorsArray.map(m => {
      // Get original default group name for badge (from allMonitors)
      const monitor = allMonitors.find(mon => mon.config && mon.config.id === m.id);
      const originalGroupName = monitor && monitor.config.group ? monitor.config.group : 'No Group';
      
      return `
        <div class="flex items-center gap-2 p-2 bg-green-900/20 border border-green-700/30 rounded-lg mb-2">
          <span class="flex-1 text-green-300">${escapeHtml(m.name)}</span>
          <span class="text-xs px-2 py-0.5 bg-gray-700/50 rounded text-gray-400">${escapeHtml(originalGroupName)}</span>
          <select onchange="updateMonitorGroup('${m.id}', this.value)" class="px-2 py-1 bg-gray-800/80 text-gray-200 border border-gray-700 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            ${statuspageGroups.map(g => `<option value="${g.id}" ${g.id === m.groupId ? 'selected' : ''}>${escapeHtml(g.name)}</option>`).join('')}
          </select>
          <button type="button" class="w-7 h-7 flex items-center justify-center bg-red-600 hover:bg-red-700 text-white rounded transition-colors text-lg" onclick="removeMonitorFromStatusPage('${m.id}')">×</button>
        </div>
      `;
    }).join('');
  }

  function updateAvailableMonitors() {
    const items = document.querySelectorAll('#available-monitors [data-monitor-id]');
    items.forEach(item => {
      const id = item.dataset.monitorId;
      const btn = item.querySelector('[data-action="add-monitor"]');
      if (selectedMonitors.has(id)) {
        item.style.opacity = '0.5';
        if (btn) btn.disabled = true;
      } else {
        item.style.opacity = '1';
        if (btn) btn.disabled = false;
      }
    });
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Add statuspage group button handler
  document.getElementById('btn-add-statuspage-group').addEventListener('click', function() {
    const name = prompt('Enter group name:');
    if (name && name.trim()) {
      statuspageGroups.push({
        id: nextGroupId--,
        name: name.trim(),
        type: 'statuspage',
        order: statuspageGroups.length + 1
      });
      renderStatuspageGroups();
      renderSelectedMonitors(); // Update dropdowns
    }
  });
  
  // Delete statuspage group
  window.deleteStatuspageGroup = function(groupId) {
    if (confirm('Delete this group? Monitors in this group will need to be reassigned.')) {
      statuspageGroups = statuspageGroups.filter(g => g.id !== groupId);
      // Reassign monitors in deleted group to first available statuspage group
      if (statuspageGroups.length > 0) {
        const firstGroupId = statuspageGroups[0].id;
        selectedMonitors.forEach((monitor, id) => {
          if (monitor.groupId === groupId) {
            monitor.groupId = firstGroupId;
            selectedMonitors.set(id, monitor);
          }
        });
      } else {
        // If no groups left, remove all monitors
        selectedMonitors.clear();
      }
      renderStatuspageGroups();
      renderSelectedMonitors();
      updateAvailableMonitors();
    }
  };

  // Initial render
  renderStatuspageGroups();
  renderSelectedMonitors();
  updateAvailableMonitors();

  // Form submission
  document.getElementById('form-configure-statuspage').addEventListener('submit', async function(e) {
    e.preventDefault();
    const fd = new FormData(e.target);
    
    // Map to track old (negative) IDs to new (positive) IDs
    const groupIdMap = new Map();
    
    // Find deleted groups (groups that were loaded but are no longer in statuspageGroups)
    const currentGroupIds = new Set(statuspageGroups.map(g => g.id));
    const deletedGroups = loadedStatusPageGroups.filter(g => !currentGroupIds.has(g.id));
    
    // Delete removed groups from database
    for (const group of deletedGroups) {
      try {
        const res = await fetch('/api/groups/' + group.id, {
          method: 'DELETE',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            csrf_token: '{{.CSRFToken}}'
          })
        });
        
        if (!res.ok) {
          console.error('Failed to delete group:', group.name);
        }
      } catch (err) {
        console.error('Failed to delete group:', err);
      }
    }
    
    // Save statuspage groups to database first and get their real IDs
    for (const group of statuspageGroups) {
      // Only save groups with negative IDs (new groups)
      if (group.id < 0) {
        try {
          const res = await fetch('/api/groups', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              name: group.name,
              type: 'statuspage',
              order: group.order,
              csrf_token: '{{.CSRFToken}}'
            })
          });
          
          if (res.ok) {
            const result = await res.json();
            // Map old negative ID to new positive ID
            groupIdMap.set(group.id, result.id);
            group.id = result.id; // Update in-memory
          }
        } catch (err) {
          console.error('Failed to save group:', err);
          alert('Failed to save group: ' + group.name);
          return;
        }
      }
    }
    
    // Update monitor groupIds with new IDs
    const monitors = Array.from(selectedMonitors.values()).map(m => {
      const newGroupId = groupIdMap.has(m.groupId) ? groupIdMap.get(m.groupId) : m.groupId;
      return {
        monitor_id: m.id,
        group_id: newGroupId,
        order: m.order
      };
    });
    
    try {
      const res = await fetch('/api/statuspages/{{.StatusPage.ID}}', {
        method: 'PUT',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          name: fd.get('name'),
          slug: fd.get('slug'),
          active: fd.get('active') === 'true',
          monitors: monitors,
          csrf_token: '{{.CSRFToken}}'
        })
      });
      
      if (res.ok) {
        window.location.href = '/admin/statuspages?success=Status page updated successfully';
      } else {
        const text = await res.text();
        alert('Error: ' + text);
      }
    } catch (err) {
      alert('Error: ' + err.message);
    }
  });
})();
</script>
{{end}}
